cells:

- markdown: |
    # Arithmetic Operations And Aggregations


- markdown: |
    Import the LArray library:


- code: |
    from larray import *

  id: 1

- markdown: |
    ## Arithmetic operations


- markdown: |
    Import a subset of the test array ``pop``:


- code: |
    # import a 6 x 2 x 2 subset of the 'pop' example array
    pop = load_example_data('demography').pop[2016, 'BruCap', 90:95]
    pop

  id: 2

- markdown: |
    One can do all usual arithmetic operations on an array, it will apply the operation to all elements individually


- code: |
    # addition
    pop + 200

  id: 3

- code: |
    # multiplication
    pop * 2

  id: 4

- code: |
    # ** means raising to the power (squaring in this case)
    pop ** 2

  id: 5

- code: |
    # % means modulo (aka remainder of division)
    pop % 10

  id: 6

- markdown: |
    More interestingly, it also works between two arrays


- code: |
    # load mortality equivalent array
    mortality = load_example_data('demography').qx[2016, 'BruCap', 90:95]
    
    # compute number of deaths
    death = pop * mortality
    death

  id: 7

- markdown: |
    <div class="alert alert-info">
    **Note:** Be careful when mixing different data types.
    You can use the method ``astype`` to change the data type of an array.
    </div>


- code: |
    # to be sure to get number of deaths as integers
    # one can use .astype() method
    death = (pop * mortality).astype(int)
    death

  id: 8

- markdown: |
    <div class="alert alert-warning">
    **Warning:** Operations between two arrays only works when they have compatible axes (i.e. same labels).
    However, it can be override but at your own risk.
    In that case only the position on the axis is used and not the labels.
    </div>


- code: |
    pop[90:92] * mortality[93:95]

  id: 9

- code: |
    pop[90:92] * mortality[93:95].drop_labels('age')

  id: 10

- markdown: |
    ### Boolean Operations


- code: |
    pop2 = pop.copy()
    pop2['F'] = -pop2['F']
    pop2

  id: 11

- code: |
    # testing for equality is done using == (a single = assigns the value)
    pop == pop2

  id: 12

- code: |
    # testing for inequality
    pop != pop2

  id: 13

- code: |
    # what was our original array like again?
    pop

  id: 14

- code: |
    # & means (boolean array) and
    (pop >= 500) & (pop <= 1000)

  id: 15

- code: |
    # | means (boolean array) or
    (pop < 500) | (pop > 1000)

  id: 16

- markdown: |
    ### Arithmetic operations with missing axes


- code: |
    pop.sum('age')

  id: 17

- code: |
    # arr has 3 dimensions
    pop.info

  id: 18

- code: |
    # and arr.sum(age) has two
    pop.sum('age').info

  id: 19

- code: |
    # you can do operation with missing axes so this works
    pop / pop.sum('age')

  id: 20

- markdown: |
    ### Axis order does not matter much (except for output)
    
    You can do operations between arrays having different axes order.
    The axis order of the result is the same as the left array


- code: |
    pop

  id: 21

- code: |
    # let us change the order of axes
    pop_transposed = pop.T
    pop_transposed

  id: 22

- code: |
    # mind blowing
    pop_transposed + pop

  id: 23

- markdown: |
    ## Aggregates
    
    Calculate the sum along an axis:


- code: |
    pop = load_example_data('demography').pop[2016, 'BruCap']
    pop.sum('age')

  id: 24

- markdown: |
    or along all axes except one by appending `_by` to the aggregation function


- code: |
    pop[90:95].sum_by('age')
    # is equivalent to
    pop[90:95].sum('sex', 'nat')

  id: 25

- markdown: |
    Calculate the sum along one group:


- code: |
    teens = pop.age[10:20]
    
    pop.sum(teens)

  id: 26

- markdown: |
    Calculate the sum along two groups:


- code: |
    pensioners = pop.age[67:]
    
    # groups from the same axis must be grouped in a tuple
    pop.sum((teens, pensioners))

  id: 27

- markdown: |
    Mixing axes and groups in aggregations:


- code: |
    pop.sum((teens, pensioners), 'nat')

  id: 28

- markdown: |
    ### More On Aggregations


- markdown: |
    There are many other aggregation functions:
    
    -  mean, min, max, median, percentile, var (variance), std (standard
       deviation)
    -  labelofmin, labelofmax (label indirect minimum/maxium -- labels where the
       value is minimum/maximum)
    -  indexofmin, indexofmax (positional indirect minimum/maxium -- position
       along axis where the value is minimum/maximum)
    -  cumsum, cumprod (cumulative sum, cumulative product)


# The lines below here may be deleted if you do not need them.
# ---------------------------------------------------------------------------
metadata:
  celltoolbar: Edit Metadata
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
  language_info:
    codemirror_mode:
      name: ipython
      version: 3
    file_extension: .py
    mimetype: text/x-python
    name: python
    nbconvert_exporter: python
    pygments_lexer: ipython3
    version: 3.6.4
  livereveal:
    autolaunch: false
    scroll: true
nbformat: 4
nbformat_minor: 2

# ---------------------------------------------------------------------------
data:
  [{execution_count: null, outputs: []}, {execution_count: null, outputs: []}, {execution_count: null,
      outputs: []}, {execution_count: null, outputs: []}, {execution_count: null, outputs: []},
    {execution_count: null, outputs: []}, {execution_count: null, outputs: []}, {execution_count: null,
      outputs: []}, {execution_count: null, outputs: []}, {execution_count: null, outputs: []},
    {execution_count: null, outputs: []}, {execution_count: null, outputs: []}, {execution_count: null,
      outputs: []}, {execution_count: null, outputs: []}, {execution_count: null, outputs: []},
    {execution_count: null, outputs: []}, {execution_count: null, outputs: []}, {execution_count: null,
      outputs: []}, {execution_count: null, outputs: []}, {execution_count: null, outputs: []},
    {execution_count: null, outputs: []}, {execution_count: null, outputs: []}, {execution_count: null,
      outputs: []}, {execution_count: null, outputs: []}, {execution_count: null, outputs: []},
    {execution_count: null, outputs: []}, {execution_count: null, outputs: []}, {execution_count: null,
      outputs: []}, {execution_count: null, outputs: []}]
